# [유기농배추](https://www.acmicpc.net/problem/1012)

- [강지웅](#강지웅) : Swift
- [서예진](#서예진) : Java
- [오나연](#오나연) : Java
- [이주형](#이주형) : Java
- [정윤영](#정윤영) : Java
- [김진산](#김진산) : Java

![image](https://user-images.githubusercontent.com/39085743/175899896-583d04b2-a0ba-4a19-be9c-4624766d8e0a.png)

## 강지웅
```swift
private let dx = [0, 0, -1, 1]
private let dy = [1, -1, 0, 0]

let T: Int = Int(readLine()!)!

var input: [Int]
var fieldState: [Int]
var field: [[Int]] = []

func getWorm(field: [[Int]]) -> Int {
    var worm: Int = 0
    var isVisited = [[Bool]](repeating: [Bool](repeating: false, count: field[0].count), count: field.count)
    
    for i in 0..<field.count {
        for j in 0..<field[0].count {
            if field[i][j] == 1 && !isVisited[i][j] {
                bfs(field: field, isVisited: &isVisited, point: [i, j])
                worm += 1
            }
        }
    }
    return worm
}

func bfs(field: [[Int]], isVisited: inout [[Bool]], point: [Int]) {
    var stack: [[Int]] = [point]
    var current: [Int]
    var next: [Int]
    isVisited[point[0]][point[1]] = true
    
    while !stack.isEmpty {
        current = stack.removeLast()
        
        for i in 0..<4 {
            next = [current[0] + dx[i], current[1] + dy[i]]
            
            if next[0] < 0 || next[0] >= field.count || next[1] < 0 || next[1] >= field[0].count {
                continue
            }
          
            if field[next[0]][next[1]] == 1 && !isVisited[next[0]][next[1]] {
                stack.append(next)
                isVisited[next[0]][next[1]] = true
            }
        }
    }
}

for _ in 0..<T {
    fieldState = readLine()!.split(separator: " ").map{ Int($0)! }
    field = [[Int]](repeating: [Int](repeating: 0, count: fieldState[0]), count: fieldState[1])
    for _ in 0..<fieldState[2] {
        input = readLine()!.split(separator: " ").map{ Int($0)! }
        field[input[1]][input[0]] = 1
    }
    
    print("\(getWorm(field: field))")
}
```
## 서예진
```java

```

## 오나연
```java

```

## 이주형
```java
```

## 정윤영
```java

```

## 김진산
```java
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.StringTokenizer;

class Main{
    //BOJ_1012_유기농 배추

    static int M, N, K;
    static int map[][];
    static boolean visited[][];
    static int delta[][] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; //상 하 좌 우

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");

        int T = Integer.parseInt(st.nextToken());
        for (int testCase = 1; testCase<= T; testCase++){{
            st = new StringTokenizer(br.readLine(), " ");

            M = Integer.parseInt(st.nextToken()); //배추밭 가로길이
            N = Integer.parseInt(st.nextToken()); //배추밭 세로길이
            K = Integer.parseInt(st.nextToken()); //배추 위치 개수

            map = new int[N][M]; //배추밭
            visited = new boolean[N][M]; //dfs 방문 여부
            for (int i = 0; i<K; i++){ //배추 위치 입력
                st = new StringTokenizer(br.readLine(), " ");
                int X = Integer.parseInt(st.nextToken());
                int Y = Integer.parseInt(st.nextToken());
                map[Y][X] = 1;
           }

            int ans = 0; //결과 값

            for (int y = 0; y<N; y++){
                for (int x = 0; x<M; x++){
                    if (map[y][x] == 1 && !visited[y][x]){ // 배추 있고 방문 안한 경우
                        ans++;
                        dfs(y, x);
                    }
                }
            }

            System.out.println(ans);
        }}

        bw.flush();
        bw.close();
        br.close();
    }

    //dfs 탐색
    public static void dfs(int y, int x){
        visited[y][x] = true;
        for (int i = 0; i<4; i++){ //4방 탐색
            int nextY = y + delta[i][0];
            int nextX = x + delta[i][1];
            if(0<= nextY && nextY <N && 0<= nextX && nextX<M){ //방문 조건
                if (!visited[nextY][nextX] && map[nextY][nextX] == 1){
                    dfs(nextY, nextX);
                }
            }
        }
    }
}

```
