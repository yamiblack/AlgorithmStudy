# [특정한 최단 ](https://www.acmicpc.net/problem/1504)

- [강지웅](#강지웅) : Swift
- [김진산](#김진산) : Java
- [서예진](#서예진) : Java
- [오나연](#오나연) : Java
- [이주형](#이주형) : Java
- [정윤영](#정윤영) : Java

![image](https://user-images.githubusercontent.com/39085743/177112640-a8a74ca1-c6e6-4888-bcd7-7a668e4994d0.png)


## 강지웅
```swift
func 특정한최단경로() {
    /**
     input start -----
     */
    var input: [Int] = readLine()!.split(separator: " ").map { Int($0)! }
    let N: Int = input[0] // node 갯수
    let E: Int = input[1] // edge 갯수
    
    /**
     그래프
     i 인덱스에는 (to, distance) 형태로 저장
     ex)
     graph[i][0].to 는 i에서의 목적지
     graph[i][0].cost 는 i에서 목적지까지의 거리
     */
    var graph: [[(to: Int, cost: Int)]] = [[(Int, Int)]](repeating: [], count: N + 1)
    
    for _ in 0..<E {
        input = readLine()!.split(separator: " ").map { Int($0)! }
        graph[input[0]].append((input[1], input[2]))
        graph[input[1]].append((input[0], input[2]))
    }
    
    input = readLine()!.split(separator: " ").map { Int($0)! }
    let v1: Int = input[0] // 경유 1
    let v2: Int = input[1] // 경유 2
    /**
     ----- input end
     */
    
    var routes: [Int] = []
    var distances: [[Int]] = [[Int]](repeating: [Int](repeating: 2_000_000_000, count: N + 1), count: N + 1)
    var isVisited: [[Bool]] = [[Bool]](repeating: [Bool](repeating: false, count: N + 1), count: N + 1)
    
    for i in 1...N {
        distances[i][i] = 0
    }
    
    getShortestDistance(from: 1)
    getShortestDistance(from: v1)
    getShortestDistance(from: v2)
    
    routes.append(distances[1][v1] + distances[v1][v2] + distances[v2][N])
    routes.append(distances[1][v2] + distances[v2][v1] + distances[v1][N])
    
    let result = routes.min()!
    
    print("\(result > 0 && result < 2_000_000_000 ? result : -1)")
    /**
     1. (1 -> v1) + (v1 -> v2) + (v2 -> N)
     2. (1 -> v2) + (v2 -> v1) + (v1 -> N)
     */
    
    func getShortestDistance(from: Int) {
        var now: Int
        
        while true {
            now = getMinIndex(from: from)
            
            if now == 0 {
                return
            }
            
            for connectedCity in graph[now] {
                if connectedCity.cost + distances[from][now] < distances[from][connectedCity.to] {
                    distances[from][connectedCity.to] = connectedCity.cost + distances[from][now]
                }
            }
        }
    }
    
    func getMinIndex(from: Int) -> Int {
        var min: Int = Int.max
        var minIndex: Int = 0
        
        for i in 1...N {
            if distances[from][i] < min && !isVisited[from][i] {
                minIndex = i
                min = distances[from][i]
            }
        }
        
        isVisited[from][minIndex] = true
        return minIndex
    }
}
```

## 김진산
```java

```

## 서예진
```java

```

## 오나연
```java

```

## 이주형
```java

```

## 정윤영
```java

```
