# [네트워크 연결](https://www.acmicpc.net/problem/1922)

- [강지웅](#강지웅) : Swift
- [김진산](#김진산) : Java
- [서예진](#서예진) : Java
- [오나연](#오나연) : Java
- [이주형](#이주형) : Java
- [정윤영](#정윤영) : Java

![image](https://user-images.githubusercontent.com/53360337/177787564-2bbb512a-1fec-4400-a7b5-accb293ff359.png)

## 강지웅
```swift

```

## 김진산
```java
import java.awt.*;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

//BOJ_1922_네트워크 연결_크루스칼
class Main{

    static int parent[];

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine(), " ");

        int N = Integer.parseInt(st.nextToken()); // 컴퓨터의 수
        int M = Integer.parseInt(br.readLine());  // 연결할 수 있는 선의 수


        int lines[][] = new int[M][3]; // 간선 정보 2차원 배열
        for (int i = 0; i<M; i++){
            st = new StringTokenizer(br.readLine(), " ");
            int from = Integer.parseInt(st.nextToken());
            int to = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());
            lines[i][0] = from;
            lines[i][1] = to;
            lines[i][2] = cost;
        }

        parent = new int[N+1]; //부모를 가리키는 배열
        for (int i = 1; i<=N; i++){ //부모를 가리키는 배열을 자기 자신이 부모가 되도록 초기화
            parent[i] = i;
        }

        Arrays.sort(lines, (o1, o2) -> o1[2] - o2[2]); //비용순으로 정렬

        int minCost = 0;
        for (int i = 0; i<M; i++){
            if (find(lines[i][0]) != find(lines[i][1])){ // from과 to가 같지 않은 경우
                union(lines[i][0], lines[i][1]); // from과 to 합치기
                minCost += lines[i][2];
            }
        }

        System.out.println(minCost);

        br.close();
    }

    public static boolean union(int a, int b){
        int aroot = find(a);
        int broot = find(b);
        if (aroot == broot) return false;

        parent[broot] = aroot;
        return true;
    }

    public static int find(int x){
        if (parent[x] == x) return x;
        else return find(parent[x]);
    }
}

```

## 서예진
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class citySplit {

    public static class Edge implements Comparable<Edge> {
        int a;
        int b;
        int w;

        Edge(int a, int b, int w){
            this.a = a;
            this.b = b;
            this.w = w;
        }
        @Override
        public int compareTo(Edge o) {
            return this.w - o.w;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        PriorityQueue<Edge> pq = new PriorityQueue();

        int a, b, weight;
        int val = 0;

        int parent[] = new int[N+1];

        for(int i = 1; i < N; i++){
            parent[i] = i;
        }

        for(int j = 0; j < M; j++){
            st = new StringTokenizer(br.readLine());
            a = Integer.parseInt(st.nextToken());
            b = Integer.parseInt(st.nextToken());
            weight = Integer.parseInt(st.nextToken());

            pq.add(new Edge(a, b, weight));
        }

        System.out.println(kruscal(pq, parent, val,N));

    }

    public static int kruscal(PriorityQueue<Edge> pq, int[] parent, int val, int N){

        int cnt = 0;

        while(!pq.isEmpty()){
            Edge item = pq.poll();
            if(union(parent, item.a, item.b)){
                val += item.w;
                cnt++;
            }
            if(cnt == N-2) break;
        }

        return val;
    }
    public static int find(int[] parent, int v){
        if(parent[v] == v){
            return v;
        }
        parent[v] = find(parent, parent[v]);

        return parent[v];
    }

    public static boolean union(int[] parent, int a, int b){
        a = find(parent, a);
        b = find(parent, b);

        if(a == b){
            return false;
        }

        if(a < b){
            parent[b] = a;
            return true;
        }
        else if(a > b){
            parent[a] = b;
            return true;
        }
        else{
            return false;
        }

    }
}
```

## 오나연
```java

```

## 이주형
```java

```

## 정윤영
```java

```
