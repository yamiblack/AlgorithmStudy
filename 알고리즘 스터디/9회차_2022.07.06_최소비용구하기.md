# [최소비용 구하기](https://www.acmicpc.net/problem/1916)

- [강지웅](#강지웅) : Swift
- [김진산](#김진산) : Java
- [서예진](#서예진) : Java
- [오나연](#오나연) : Java
- [이주형](#이주형) : Java
- [정윤영](#정윤영) : Java

![image](https://user-images.githubusercontent.com/39085743/177111989-a175fec4-cec2-41ec-abbe-ca7a2f16a519.png)


## 강지웅
```swift
func 최소비용구하기() {
    var input: [Int]
    let N: Int = Int(readLine()!)!
    let M: Int = Int(readLine()!)!
    
    var graph: [[(to: Int, cost: Int)]] = [[(Int, Int)]](repeating: [], count: N + 1)
    
    for _ in 0..<M {
        input = readLine()!.split(separator: " ").map { Int($0)! }
        graph[input[0]].append((input[1], input[2]))
    }
    
    input = readLine()!.split(separator: " ").map { Int($0)! }
    let from: Int = input[0]
    let to: Int = input[1]
    
    var minCosts: [Int] = [Int](repeating: Int.max, count: N + 1)
    var isVisited: [Bool] = [Bool](repeating: false, count: N + 1)
    minCosts[from] = 0
    
    dijkstra()
    
    print("\(minCosts[to])")
    
    func dijkstra() {
        var now: Int
        
        while true {
            now = getMinIndex()
            
            if now == 0 {
                return
            }
            
            for connectedCity in graph[now] {
                if connectedCity.cost + minCosts[now] < minCosts[connectedCity.to] {
                    minCosts[connectedCity.to] = connectedCity.cost + minCosts[now]
                }
            }
        }
    }
    
    func getMinIndex() -> Int {
        var min: Int = Int.max
        var minIndex: Int = 0
        
        for i in 1...N {
            if minCosts[i] < min && !isVisited[i] {
                minIndex = i
                min = minCosts[i]
            }
        }
        
        isVisited[minIndex] = true
        return minIndex
    }
}
```

## 김진산
```java

```

## 서예진
```java

```

## 오나연
```java

```

## 이주형
```java

```

## 정윤영
```java

```
